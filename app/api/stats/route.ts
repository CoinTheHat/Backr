import { NextResponse } from 'next/server';
import { supabase } from '@/utils/supabase';

export async function GET(request: Request) {
    const { searchParams } = new URL(request.url);
    const creatorAddress = searchParams.get('creator');

    if (!creatorAddress) {
        return NextResponse.json({ error: 'Creator address required' }, { status: 400 });
    }

    // 1. Get active subscriptions count
    const { count: membersCount, error: subError } = await supabase
        .from('subscriptions')
        .select('*', { count: 'exact', head: true })
        .eq('creatorAddress', creatorAddress);

    if (subError) {
        console.error('Stats error (subs):', subError);
    }

    // 2. Calculate Revenue (Approximate based on tiers for MVP)
    // Ideally we sum up actual transaction values, but for now we look at active subs and their tiers.
    // Fetch all subscriptions with their tier details (if stored) or just join.
    // Since we don't have a 'price' in subscription table, we fetch tiers first.

    // Fetch tiers to map price
    const { data: tiers } = await supabase
        .from('tiers')
        .select('name, price') // Price is string in DB likely, based on previous files
        .eq('creatorAddress', creatorAddress);

    // Fetch actual subscriptions with tier info
    const { data: subscriptions } = await supabase
        .from('subscriptions')
        .select('tierName, tierId') // We use tierId mostly now
        .eq('creatorAddress', creatorAddress);

    let totalRevenue = 0;

    // Map tier prices
    const tierPriceMap: Record<string, number> = {};
    const tierIdPriceMap: Record<number, number> = {}; // If we used IDs

    // Note: Tiers in DB might not have IDs if they rely on array index, but let's assume names match or logic holds.
    // In valid system, we'd sum 'transactions' table.

    if (tiers && subscriptions) {
        tiers.forEach((t: any, index: number) => {
            // Try to handle price as number
            const p = parseFloat(t.price);
            tierPriceMap[t.name] = p;
            // Approximate ID match if array usage matches creation order (0-indexed)
            // But tierId in sub might be off.
        });

        subscriptions.forEach((sub: any) => {
            // Try matching by ID first (since we saved tierId recently)
            // If tierId is present.
            // For MVP, simplistic calculation:
            // If sub has tierName, use it.
            if (sub.tierName && tierPriceMap[sub.tierName]) {
                totalRevenue += tierPriceMap[sub.tierName];
            } else {
                // Fallback or if using IDs, we need to know price of that ID.
                // Assuming subscription logic we implemented:
                // "tierId: 0" was passed.
                // If we accept that 1 subscription = 1 month of revenue roughly.
                // This calculates "current monthly run rate" (MRR) basically.
                // Let's assume average price 10 MNT if unknown for hackathon demo if data missing.
            }
        });

        // BETTER APPROACH FOR HACKATHON DEMO:
        // Use the 'lifetime' or 'amount' if we had it.
        // Let's just calculate based on a mock lookup or simplify significantly.
        // Let's just sum (Count * Est Average) or use simpler logic if complex.
        // Actually, let's try to match exactly if possible.
        // We saved `tierId` in the recent `app/[creator]/page.tsx` update.
        // And we have tiers.

        subscriptions.forEach((sub: any) => {
            // We need to match sub.tierId to the tier's price.
            // But 'tiers' from DB doesn't have ID column if generated by identity? 
            // supabase_schema said "tiers" table? Wait, we store tiers in a JSON column or separate table?
            // "fetch('/api/tiers')" returns array. API route says `supabase.from('tiers')`.
            // Tiers table likely has IDs?
            // Let's assume tiers[sub.tierId] works if sub.tierId is valid index.
            if (typeof sub.tierId === 'number' && tiers[sub.tierId]) {
                totalRevenue += parseFloat(tiers[sub.tierId].price);
            } else if (sub.tierId === 0 && tiers.length > 0) {
                // Default to first tier
                totalRevenue += parseFloat(tiers[0].price);
            }
        });
    }

    return NextResponse.json({
        activeMembers: membersCount || 0,
        monthlyRevenue: totalRevenue.toFixed(2),
        totalWithdrawals: "0.00" // Placeholder until we track withdrawals
    });
}
